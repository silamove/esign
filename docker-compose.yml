services:
  postgres:
    image: postgres:17-alpine
    user: "0:0"
    environment:
      POSTGRES_USER: sign
      POSTGRES_PASSWORD: signpass
      POSTGRES_DB: sign
      # Optional: tune locale & encoding
      # LANG: en_US.utf8
      # POSTGRES_INITDB_ARGS: "--encoding=UTF8 --lc-collate=C --lc-ctype=C"
    # Expose to host for development (psql/pgAdmin). Remove in production.
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 20s
    security_opt:
      - no-new-privileges:true
    tmpfs:
      - /var/run/postgresql:rw,noexec,nosuid,nodev,size=8m
      - /tmp:rw,noexec,nosuid,nodev,size=16m
    ulimits:
      nproc: 256
      nofile: 8192
    pids_limit: 256
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"
    restart: unless-stopped
    networks:
      - internal

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    environment:
      NODE_ENV: production
      PORT: 3001
      DB_CLIENT: pg
      # Use the internal Postgres service by default
      PGHOST: postgres
      PGPORT: 5432
      PGDATABASE: sign
      PGUSER: sign
      PGPASSWORD: signpass
      # E2E cryptographic signing + trusted timestamping
      HSM_PROVIDER: sigstore_cosign
      COSIGN_MODE: keyless
      COSIGN_FULCIO_URL: https://fulcio.sigstore.dev
      COSIGN_REKOR_URL: https://rekor.sigstore.dev
      COSIGN_EXPERIMENTAL: "true"
      # Optional OIDC identity token for non-interactive signing (GitHub Actions, etc.)
      # COSIGN_IDENTITY_TOKEN: ${COSIGN_IDENTITY_TOKEN:-}
      # Optional: password if using key mode
      # COSIGN_PASSWORD: ${COSIGN_PASSWORD:-}
      # Optional: KMS URI if using kms mode
      # COSIGN_KMS_URI: ${COSIGN_KMS_URI:-}
      DATABASE_TYPE: postgresql
      DATABASE_HOST: postgres
      DATABASE_PORT: 5432
      DATABASE_NAME: sign
      DATABASE_USER: sign
      DATABASE_PASSWORD: signpass
      DATABASE_SSL: "false"
      SMTP_HOST: mailhog
      SMTP_PORT: 1025
      SMTP_SECURE: "false"
      SMTP_USER: dev
      SMTP_PASS: dev
      SMTP_FROM: "OnDottedLine <noreply@ondottedline.local>"
    depends_on:
      postgres:
        condition: service_healthy
      mailhog:
        condition: service_started
    # No direct host port; route via nginx
    # ports:
    #   - "3001:3001"
    command: sh -c "npm start"
    healthcheck:
      test: [
        "CMD",
        "node",
        "-e",
        "require('http').request({host:'localhost',port:process.env.PORT||3001,path:'/api/health'}).on('response',r=>process.exit(r.statusCode===200?0:1)).on('error',()=>process.exit(1)).end()"
      ]
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 30s
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs:
      - /tmp:rw,noexec,nosuid,nodev,size=64m
    ulimits:
      nproc: 256
      nofile: 4096
    pids_limit: 256
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"
    cap_drop:
      - ALL
    restart: unless-stopped
    networks:
      - internal
    volumes:
      - uploads:/app/uploads

  tsa:
    image: ghcr.io/sigstore/timestamp-server:latest
    # For dev, this will use an in-memory signer. For production, mount a cert chain
    # and configure a KMS/Tink signer as per sigstore/timestamp-authority docs.
    command: ["serve", "--port", "3000"]
    # Do not expose to host; internal only (backend calls it directly)
    # ports:
    #   - "3000:3000"
    # volumes:
    #   - ./tsa/chain.crt.pem:/chain.crt.pem:ro
    # environment:
    #   - TIMESTAMP_SIGNER=tink
    #   - CERTIFICATE_CHAIN_PATH=/chain.crt.pem
    #   - TINK_KEY_RESOURCE=gcp-kms://projects/..../cryptoKeys/<key>
    #   - TINK_KEYSET_PATH=/secrets/enc-keyset.cfg
    healthcheck:
      test: ["CMD-SHELL", "wget -qO- http://localhost:3000/api/v1/timestamp/certchain >/dev/null 2>&1 || exit 1"]
      interval: 15s
      timeout: 5s
      retries: 10
      start_period: 30s
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs:
      - /tmp:rw,noexec,nosuid,nodev,size=32m
    ulimits:
      nproc: 256
      nofile: 2048
    pids_limit: 128
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"
    cap_drop:
      - ALL
    restart: unless-stopped
    networks:
      - internal
    profiles:
      - tsa

  # Hardened TLS reverse proxy with security headers
  nginx:
    image: nginx:1.27-alpine
    depends_on:
      backend:
        condition: service_healthy
      devcerts:
        condition: service_started
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - nginx_cache:/var/cache/nginx
      - nginx_certs:/etc/nginx/certs
      - ./nginx/entrypoint.sh:/docker-entrypoint.d/99-tls-entrypoint.sh:ro
    environment:
      TLS_MODE: ${TLS_MODE:-auto}
      TLS_DOMAIN: ${TLS_DOMAIN:-localhost}
      TLS_CERT_DIR: /etc/nginx/certs
      TLS_P12_PATH: /etc/nginx/certs/server.p12
      TLS_P12_PASSWORD: ${TLS_P12_PASSWORD:-}
      SIGNING_CERT_B64: ${SIGNING_CERT_B64:-}
    healthcheck:
      test: ["CMD-SHELL", "nginx -t"]
      interval: 30s
      timeout: 5s
      retries: 3
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs:
      - /run:rw,noexec,nosuid,nodev,size=16m
      - /tmp:rw,noexec,nosuid,nodev,size=32m
    cap_drop:
      - ALL
    restart: unless-stopped
    networks:
      - internal
      - edge

  # One-shot (kept running) container to generate dev CA and localhost certs inside a Docker volume
  devcerts:
    image: alpine:3.20
    entrypoint: ["/bin/sh", "-ec"]
    command: >-
      apk add --no-cache openssl;
      cd /work;
      if [ ! -f server.crt ] || [ ! -f server.key ]; then
        echo "Generating localhost self-signed cert...";
        openssl req -x509 -newkey rsa:2048 -sha256 -days 365 \
          -nodes -subj "/CN=localhost" \
          -keyout server.key -out server.crt \
          -addext "subjectAltName=DNS:localhost,IP:127.0.0.1,IP:::1" \
          -addext "extendedKeyUsage=serverAuth" \
          -addext "keyUsage=digitalSignature,keyEncipherment";
      else
        echo "Existing certs found in volume.";
      fi;
      exec tail -f /dev/null
    volumes:
      - nginx_certs:/work
    security_opt:
      - no-new-privileges:true
    read_only: false
    networks:
      - internal
    healthcheck:
      test: ["CMD-SHELL", "[ -f /work/server.crt ] && [ -f /work/server.key ] || exit 1"]
      interval: 30s
      timeout: 5s
      retries: 5
      start_period: 10s
    logging:
      driver: json-file
      options:
        max-size: "5m"
        max-file: "2"
    restart: unless-stopped

  # Optional: cosign CLI for countersigning/verification automation
  cosign:
    image: ghcr.io/sigstore/cosign/cosign:latest
    entrypoint: ["sleep", "infinity"]
    # Mount a workspace dir to persist cosign keys if you generate them
    volumes:
      - ./cosign:/workspace
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs:
      - /tmp
    ulimits:
      nproc: 128
      nofile: 1024
    pids_limit: 64
    logging:
      driver: json-file
      options:
        max-size: "5m"
        max-file: "2"
    cap_drop:
      - ALL
    restart: unless-stopped
    networks:
      - internal
    profiles:
      - security-tools

  # Development SMTP server (MailHog) for catching emails
  mailhog:
    image: mailhog/mailhog:v1.0.1
    ports:
      - "1025:1025"   # SMTP
      - "8025:8025"   # Web UI
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs:
      - /tmp
    restart: unless-stopped
    networks:
      - internal

volumes:
  pgdata:
  nginx_cache:
  uploads:
  nginx_certs:

networks:
  internal:
    driver: bridge
  edge:
    driver: bridge
